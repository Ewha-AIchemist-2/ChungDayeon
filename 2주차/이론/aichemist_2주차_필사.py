# -*- coding: utf-8 -*-
"""AIchemist_2주차_필사.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pKBNLKMRpxzofAMWjbENe3THwUvFuROb
"""

# Commented out IPython magic to ensure Python compatibility.
#라이브러리 불러오기
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline

from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, precision_score, recall_score, roc_auc_score
from sklearn.metrics import f1_score, confusion_matrix, precision_recall_curve, roc_curve
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression

import warnings
warnings.filterwarnings('ignore')

#데이터 불러오기
diabetes_data = pd.read_csv('pima indian/diabetes.csv')

print(diabetes_data['Outcome'].value_counts())
diabetes_data.head(3)
diabetes_data.info()

#로지스틱 회귀를 이용한 예측 모델 생성
def get_clf_eval(y_test, y_pred):
    confusion = confusion_matrix( y_test, y_pred)
    accuracy = accuracy_score(y_test , y_pred)
    precision = precision_score(y_test , y_pred)
    recall = recall_score(y_test , y_pred)
    f1 = f1_score(y_test,y_pred)

    print('오차 행렬 : \n', confusion)
    print('\n정확도 : {:.4f}'.format(accuracy))
    print('정밀도 : {:.4f}'.format(precision))
    print('재현율 : {:.4f}.format(recall))
    print('F1 : {:.4f}'.format(F1))
    print('AUC : {:.4f}'.format(AUC))

    #Precision-Recall Curve Plot 그리기
    def precision_recall_curve_plot(y_test, pred_proba):
    # threshold ndarray와 이 threshold에 따른 정밀도, 재현율 ndarray 추출.
    precisions, recalls, thresholds = precision_recall_curve(y_test, pred_proba)
    # X축을 threshold값으로, Y축은 정밀도, 재현율 값으로 각각 Plot 수행. 정밀도는 점선으로 표시
    plt.figure(figsize=(8,6))
    threshold_boundary = thresholds.shape[0]
    plt.plot(thresholds, precisions[0:threshold_boundary], linestyle='--', label='precision')
    plt.plot(thresholds, recalls[0:threshold_boundary],label='recall')

    # threshold의 값 X축의 scale을 0.1 단위로 변경
    start, end = plt.xlim()
    plt.xticks(np.round(np.arange(start, end, 0.1),2))

    # x축, y축 label과 legend, 그리고 grid 설정
    plt.xlim()
    plt.xlabel('Threshold value'); plt.ylabel('Precision and Recall value')
    plt.legend(); plt.grid()
    #피쳐 데이터 세트 X, 레이블 데이터 세트 y를 추출
    X = diabetes_data.iloc[:, :-1] # Feature (Outcome 외)
    y = diabetes_data.iloc['Outcome'] # Label (Outcome)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 156, stratify=y)
#로지스틱 회귀로 학습, 예측 및 평가 수행
lr_clf = LogisticRegression()
lr_clf.fit(X_train , y_train)
pred = lr_clf.predict(X_test)
get_clf_eval(y_test , pred, pred_proba)
#임계값별로 정밀도-재현율 출력
pred_proba_c1 = lr_clf.predict_proba(X_test)[:, 1]
precision_recall_curve_plot(y_test, pred_proba_c1)
diabetes_data.describe()

feature_list=['Glucose','BloodPressure','SkinThickness','Insulin','BMI']
def hist_plot(df):
  for col in feature_list:
          df[col].plot(kind='hist', bins=20).set_title('Histogram of '+col)
          plt.show()
  hist_plot(diabetes_data)

#0 값의 비율 확인
zero_count=[]
zero_percent=[]
for col in feature_list:
          zero_num=diabetes_data[diabetes_data[col]=0].shape[0]
          zero_count.append(zero_num)
          zero_percent.append(np.round(zero_num/diabetes_data.shape[0]*100, 2))
zero=pd.DataFrame([zero_count, zero_percent], columns=feature_list, index=['count','percent']).T
zero
 0 값들을 우선 NaN 값으로 대체
diabetes_data[feature_list] = diabetes_data[feature_list].replace(0, np.nan)

# 위 5개 feature 에 대해 0값을 평균 값으로 대체
mean_features = diabetes_data[feature_list].mean()
diabetes_data[feature_list] = diabetes_data[feature_list].replace(np.nan, mean_features)
# 데이터 세트에 대해 피처 스케일링을 적용하여 변환하기(로지스틱 회귀의 경우, 숫자 데이터에 스케일링을 적용하는 것이 일반적으로 성능이 좋음)
X = diabetes_data.iloc[:, :-1]
y = diabetes_data.iloc[:, -1]

# StandardScaler 클래스를 상용하여 데이터 세트에 스케일링 적용
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size = 0.2, random_state=156, stratify = y)

# 로지스틱 회귀로 학습, 예측, 평가 수행
lr_clf = LogisticRegression()
lr_clf.fit(X_train,  y_train)
pred = lr_clf.predict(X_test)
get_clf_eval(y_test, pred)

# 평가지표를 조사하기 위한 새로운 함수 생성
def get_eval_by_threshold(y_test, pred_proba_c1, thresholds):
    #thresholds list 객체 내의 값을 iteration 하면서 평가 수행
    for custom_threshold in thresholds:
        binarizer = Binarizer(threshold=custom_threshold).fit(pred_proba_c1)
        custom_predict = binarizer.transform(pred_proba_c1)
        print('\n임계값: ', custom_threshold)
        get_clf_eval(y_test, custom_predict)

#임계값 변화에 따른 예측 성능 확
thresholds = [0.3, 0.33, 0.36, 0.39, 0.42, 0.45, 0.48, 0.50]
pred_proba = lr_clf.predict_proba(X_test)
get_eval_by_threshold(y_test, pred_proba[:, 1].reshape(-1, 1), thresholds)

# 임계값을 0.48로 설정하여 예측 수행
binarizer = Binarizer(threshold=0.48)

# 위에서 구한 predict_proba() 예측확률의 array에서 1에 해당하는 컬럼 값을 대입하여 Binarizer 반환하기
pred_th_048 = binarizer.fit_transform(pred_proba[:, 1].reshape(-1, 1))

get_clf_eval(y_test, pred_th_048)